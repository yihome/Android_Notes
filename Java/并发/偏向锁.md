## synchronized

`Java` 可以使用 `synchronized` 关键字对于方法或者代码块进行加锁，在JDK1.6以前，`synchronized` 的加锁过程由 `monitor` 完成，在试图进入临界区时，会尝试获取 `monitor` 的所有权，成功则获得锁，失败则阻塞知道其他线程释放锁，在 `JDK1.6` 以及以后版本，引入了偏向锁来减少锁的消耗，锁一共有四种状态，无锁、偏向锁、轻量级锁、重量级锁。

## 锁的标记

`synchronized` 的锁都是作用在特定对象上的，方法和没有指定加锁对象的代码块的锁都是作用在当前对象上的，静态方法的锁是作用在类的 `Class` 对象上的，锁的标记保存在对象头中，对象头中会保存锁的状态，以及锁的其他信息（持有锁的线程ID、指向锁的记录的指针等）

> 对象头中除了锁的信息外还会保存一些对象的其他信息，比如hashCode、分代年龄等

## 偏向锁

偏向锁的信息只保存在对象头中，一个线程获取锁时，只是简单的将对象头和栈桢中的锁记录里存储线程ID（同时将偏向锁标志位置1，通过CAS），在释放锁的时候不会做任何操作，下此试图获取锁时检查如果锁的记录指向自己则直接获取锁

当第二个线程试图获取锁时，会出发偏向锁撤销，即会在一个全局安全点，检查持有偏向锁的线程，如果线程死亡则将锁置为无锁状态，如果没有则会检查桢栈，如果线程已经离开临界区则将对象头置为新的线程，否则锁会膨胀到下一级别

## 轻量级锁

在执行同步块前会在栈桢中分配用于存储锁记录的空间，并把对象头的mark work复制到锁记录中，然后是使用CAS操作将对象头中的`mark word` 替换为指向锁记录的指针，如果成功则获得锁，失败则自旋获取锁，自旋获取失败后将会膨胀为重量级锁

轻量级锁在解锁时也会将之前存到锁记录的 `mark work` 替换回到对象头中。